// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider   = "prisma-client-js"
  engineType = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String    @id @default(cuid())
  email           String?   @unique
  phone           String?   @unique
  passwordHash    String?
  role            Role
  isEmailVerified Boolean   @default(false)
  twoFAEnabled    Boolean   @default(false)
  twoFASecret     String?
  lastLoginAt     DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  sessions Session[]
  tokens   Token[]
  otps     OtpCode[]

  merchantProfiles MerchantProfile[]
  createdOrders    Order[]           @relation("CreatedByUserOrders")

  // Dispatch back-relations
  deliveriesAssigned Delivery[]      @relation("AssignedDriver")
  offers             Offer[]         @relation("OfferDriver")
  driverPresence     DriverPresence? @relation("PresenceDriver")

  // KYC 1:1 (owned by user)
  driverKyc DriverKyc? @relation("UserDriverKyc")

  // Admin reviewer back-relations (for reviewedBy on KYC records)
  reviewedDriverKycs   DriverKyc[]   @relation("DriverKycReviewedBy")
  reviewedMerchantKycs MerchantKyc[] @relation("MerchantKycReviewedBy")
}

model Session {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshHash String
  userAgent   String?
  ip          String?
  createdAt   DateTime  @default(now())
  expiresAt   DateTime
  revokedAt   DateTime?
}

model Token {
  id         String    @id @default(cuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type       TokenType
  tokenHash  String
  expiresAt  DateTime
  consumedAt DateTime?
  createdAt  DateTime  @default(now())

  @@index([userId, type, expiresAt])
}

model OtpCode {
  id          String     @id @default(cuid())
  userId      String?
  user        User?      @relation(fields: [userId], references: [id], onDelete: SetNull)
  destination String
  channel     OtpChannel
  purpose     OtpPurpose
  code        String
  expiresAt   DateTime
  consumedAt  DateTime?
  createdAt   DateTime   @default(now())

  @@index([destination, purpose, expiresAt])
}

enum Role {
  ADMIN
  USER
  DRIVER
}

enum CreatorType {
  GUEST
  USER
  MERCHANT
}

enum MerchantStatus {
  PENDING
  ACTIVE
  SUSPENDED
}

enum TokenType {
  EMAIL_VERIFY
  PASSWORD_RESET
}

enum OtpChannel {
  EMAIL
  SMS
}

enum OtpPurpose {
  LOGIN
  STEP_UP
}

enum OrderStatus {
  DRAFT
  PENDING_PAYMENT
  PAID_HELD
  RELEASED
  CANCELLED
}

enum PaymentProvider {
  DUMMY
  PAYSTACK
}

enum PaymentStatus {
  REQUIRES_PAYMENT
  PENDING
  SUCCEEDED
  FAILED
}

enum AccountType {
  ASSET
  LIABILITY
  INCOME
  EXPENSE
}

enum AccountPurpose {
  ESCROW
  FEES
  CASH_GATEWAY
  DRIVER_PAYABLE
  MERCHANT_RECEIVABLE
}

enum JournalSide {
  DEBIT
  CREDIT
}

model Order {
  id          String      @id @default(cuid())
  publicRef   String      @unique @default(cuid())
  creatorType CreatorType

  // Auth buyer
  createdByUserId String?
  createdByUser   User?   @relation("CreatedByUserOrders", fields: [createdByUserId], references: [id], onDelete: SetNull)

  // Auth seller (merchant profile)
  createdByMerchantId String?
  createdByMerchant   MerchantProfile? @relation("CreatedByMerchantOrders", fields: [createdByMerchantId], references: [id], onDelete: SetNull)

  // Guest contact
  customerName  String?
  customerPhone String?
  customerEmail String?

  currency  String
  amount    Int
  status    OrderStatus
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  paymentIntents PaymentIntent[]
  deliveries     Delivery[] // back-rel to Delivery.order
  OrdrItem       OrdrItem[]
}

model PaymentIntent {
  id          String          @id @default(cuid())
  orderId     String
  order       Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  provider    PaymentProvider
  providerRef String
  status      PaymentStatus
  amount      Int
  currency    String
  metadata    Json?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@unique([provider, providerRef])
}

model WebhookEvent {
  id              String          @id @default(cuid())
  provider        PaymentProvider
  providerEventId String
  payload         Json
  receivedAt      DateTime        @default(now())
  processedAt     DateTime?
  success         Boolean?

  @@unique([provider, providerEventId])
}

model WalletAccount {
  id        String         @id @default(cuid())
  ownerType String
  ownerId   String?
  purpose   AccountPurpose
  type      AccountType
  currency  String
  createdAt DateTime       @default(now())

  journalEntries JournalEntry[]

  @@unique([ownerType, ownerId, purpose, currency])
}

model JournalEntry {
  id        String        @id @default(cuid())
  txnId     String
  lineNo    Int
  accountId String
  account   WalletAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  side      JournalSide
  amount    Int
  currency  String
  meta      Json?
  createdAt DateTime      @default(now())

  @@unique([txnId, lineNo])
  @@index([accountId])
}

model MerchantProfile {
  id        String         @id @default(cuid())
  userId    String
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  storeName String
  slug      String         @unique
  status    MerchantStatus @default(PENDING)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  orders Order[] @relation("CreatedByMerchantOrders")

  kyc     MerchantKyc?
  Product Product[]
}

// ===== Dispatch v1 =====

enum DeliveryStatus {
  NEW
  OFFERING
  ASSIGNED
  PICKED_UP
  DELIVERED
  CANCELLED
}

enum OfferStatus {
  SENT
  ACCEPTED
  DECLINED
  EXPIRED
}

enum DeliveryEventKind {
  OFFER_SENT
  OFFER_ACCEPTED
  OFFER_DECLINED
  OFFER_EXPIRED
  DRIVER_ASSIGNED
  DRIVER_ARRIVED
  PICKED_UP
  DELIVERED
  CANCELLED
  LOCATION_UPDATE
  NOTE
}

model Offer {
  id         String   @id @default(cuid())
  deliveryId String
  delivery   Delivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  driverId String
  driver   User   @relation("OfferDriver", fields: [driverId], references: [id], onDelete: Cascade)

  status    OfferStatus
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([deliveryId, driverId])
  @@index([driverId])
  @@index([deliveryId, status])
}

model DriverPresence {
  driverId   String   @id
  driver     User     @relation("PresenceDriver", fields: [driverId], references: [id], onDelete: Cascade)
  online     Boolean  @default(false)
  lastSeenAt DateTime @default(now())
  lat        Decimal?
  lng        Decimal?
  updatedAt  DateTime @updatedAt
}

model Delivery {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  status           DeliveryStatus
  assignedDriverId String?
  assignedDriver   User?          @relation("AssignedDriver", fields: [assignedDriverId], references: [id], onDelete: SetNull)

  // Routing data
  pickupAddress  String?
  pickupLat      Decimal?
  pickupLng      Decimal?
  dropoffAddress String?
  dropoffLat     Decimal?
  dropoffLng     Decimal?

  // Status timestamps + PoD fields
  pickedUpAt        DateTime?
  deliveredAt       DateTime?
  podCode           String?
  podVerifiedAt     DateTime?
  recipientName     String?
  recipientPhotoUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  offers Offer[]
  events DeliveryEvent[]

  @@index([orderId])
  @@index([assignedDriverId])
}

model DeliveryEvent {
  id          String            @id @default(cuid())
  deliveryId  String
  delivery    Delivery          @relation(fields: [deliveryId], references: [id], onDelete: Cascade)
  actorUserId String?
  kind        DeliveryEventKind
  data        Json?
  at          DateTime          @default(now())

  @@index([deliveryId, at])
}

// ===== KYC =====

enum KycStatus {
  PENDING
  APPROVED
  REJECTED
}

model DriverKyc {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation("UserDriverKyc", fields: [userId], references: [id], onDelete: Cascade)

  fullName      String
  idNumber      String
  licenseNumber String
  licenseExpiry DateTime?
  vehicleType   String?
  vehiclePlate  String?

  idDocUrl      String?
  licenseDocUrl String?
  selfieUrl     String?

  status       KycStatus @default(PENDING)
  reviewNote   String?
  reviewedById String?
  reviewedBy   User?     @relation("DriverKycReviewedBy", fields: [reviewedById], references: [id])
  reviewedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

model MerchantKyc {
  id                String          @id @default(cuid())
  merchantProfileId String          @unique
  merchantProfile   MerchantProfile @relation(fields: [merchantProfileId], references: [id], onDelete: Cascade)

  contactName  String
  businessName String?
  taxId        String?
  address      String?
  docUrl       String?

  status       KycStatus @default(PENDING)
  reviewNote   String?
  reviewedById String?
  reviewedBy   User?     @relation("MerchantKycReviewedBy", fields: [reviewedById], references: [id])
  reviewedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}

// ===== Catalog =====

enum ProductStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model Category {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  products ProductCategory[]
}

model Product {
  id                String          @id @default(cuid())
  merchantProfileId String
  merchantProfile   MerchantProfile @relation(fields: [merchantProfileId], references: [id], onDelete: Cascade)

  title       String
  description String?
  status      ProductStatus @default(DRAFT)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  variants   ProductVariant[]
  media      ProductMedia[]
  categories ProductCategory[]

  @@index([merchantProfileId, status])
  @@index([status])
}

model ProductVariant {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  sku       String  @unique
  title     String
  currency  String
  price     Int // minor units
  stock     Int     @default(0) // simple stock; adjust on payment success later
  isDefault Boolean @default(false)
  active    Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId, active])
}

model ProductMedia {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  url       String
  position  Int      @default(0)
  createdAt DateTime @default(now())
}

model ProductCategory {
  productId  String
  categoryId String
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([productId, categoryId])
  @@index([categoryId])
}

// ===== Orders: line items =====

model OrdrItem {
  id      String @id @default(cuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // snapshot fields to preserve pricing even if product changes later
  productId    String?
  variantId    String?
  title        String // product title snapshot
  variantTitle String?
  unitPrice    Int // minor
  currency     String
  quantity     Int

  createdAt DateTime @default(now())

  @@index([orderId])
}
